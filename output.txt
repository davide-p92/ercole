// tsconfig.json
{
  "compilerOptions": {
    "target": "es2020",
    "module": "commonjs",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "./dist",
    "rootDir": "./"
  },
  "include": ["scripts/**/*"],
  "exclude": ["node_modules", "dist"]
}


// notes-index.json
[
  {
    "id": "hello",
    "path": "hello.md",
    "title": "Hello Ercole",
    "created": "Sun Feb 08 2026 00:00:00 GMT+0000 (Coordinated Universal Time)",
    "updated": "Sun Feb 08 2026 00:00:00 GMT+0000 (Coordinated Universal Time)",
    "tags": [
      "test"
    ],
    "links": [],
    "content": "Questa √® una nota di prova su transformer e latent diffusion.",
    "content_hash": "ab897c92a9792574f7e757fc3bda8aa7e5f049a0f75f2aa4f09bc230cfd4a21a"
  }
]

// debug-sqlite.js
// debug-sqlite.js
async function debugSQLite() {
  try {
    console.log('Debugging SQLite WASM import...');
    
    // Try different import methods
    const module1 = await import('@sqlite.org/sqlite-wasm');
    console.log('Method 1 - Full module:', Object.keys(module1));
    
    // Try accessing default
    console.log('Method 1 - Has default?', 'default' in module1);
    if (module1.default) {
      console.log('Method 1 - Default type:', typeof module1.default);
    }
    
    // Try direct properties
    console.log('Method 1 - Direct version property?', 'version' in module1);
    console.log('Method 1 - Direct oo1 property?', 'oo1' in module1);
    
  } catch (error) {
    console.error('Debug error:', error);
  }
}

debugSQLite();


// scripts/watch.ts
import chokidar from "chokidar";
import path from "path";
import fs from "fs";
import matter from "gray-matter";
import crypto from "crypto";
import { dirname } from 'node:path';
import { fileURLToPath } from 'node:url';
import { validateFrontmatter } from "./frontmatter.ts";

const __dirname = dirname(fileURLToPath(import.meta.url));

const NOTES_DIR = path.resolve(__dirname, "../notes");
const INDEX_PATH = path.resolve(__dirname, "../notes-index.json");

// --- Types ---
interface Note {
  id: string;
  path: string;
  title: string;
  created: string;
  updated: string;
  tags: string[];
  links: string[];
  content: string;
  content_hash: string;
}


// --- debounce/batch state ---
let pendingSaves = false;
let saveTimer: NodeJS.Timeout | null = null;
const SAVE_DEBOUNCE_MS = 400; // regola a piacere

function scheduleSave(db: JSONDatabase) {
  pendingSaves = true;
  if (saveTimer) clearTimeout(saveTimer);
  saveTimer = setTimeout(() => {
    try {
      db.save();
    } finally {
      pendingSaves = false;
      saveTimer = null;
    }
  }, SAVE_DEBOUNCE_MS);
}

class JSONDatabase {
  private notes: Map<string, Note> = new Map();

  constructor() {
    this.load();
  }

  // Load index from disk if present
  load() {
    if (fs.existsSync(INDEX_PATH)) {
      try {
        const data = JSON.parse(fs.readFileSync(INDEX_PATH, "utf8"));
        this.notes.clear();
        data.forEach((note: Note) => this.notes.set(note.id, note));
        console.log(`üìö Loaded ${this.notes.size} notes from index`);
      } catch (err) {
        console.error("Failed to load index:\n", err);
      }
    }
  }

  save() {
    fs.writeFileSync(
      INDEX_PATH,
      JSON.stringify([...this.notes.values()], null, 2)
    );
    console.log(`üíæ Saved index (${this.notes.size} notes)`);
  }

  removeByPath(relPath: string) {
    for (const [id, note] of this.notes.entries()) {
      if (note.path === relPath) {
        this.notes.delete(id);
        console.log(`üóë Removed: ${relPath}`);
        return;
      }
    }
  }
  upsertFromFile(filePath: string) {
    try {
      const changed = this.parseAndMaybeUpsert(filePath);
      if (changed) {
        scheduleSave(this);
      } else {
        // niente da salvare (hash invariato)
        // console.log(`‚ÜîÔ∏è No change: ${path.relative(NOTES_DIR, filePath)}`);
      }
    } catch (err: any) {
      console.error(`‚ùå Error parsing ${filePath}:`, err.message);
    }
  }

  sha256(text: string) {
    return crypto.createHash("sha256").update(text).digest("hex");
  }

  parseNote(filePath: string): Note {
    const raw = fs.readFileSync(filePath, "utf8");
    const parsed = matter(raw);

    const data = parsed.data as any;
    const rel = path.relative(NOTES_DIR, filePath);
    validateFrontmatter(data, rel);

    if (!data.id) throw new Error(`Missing id in ${rel}`);
    if (!data.title) throw new Error(`Missing title in ${rel}`);
    if (!data.created) throw new Error(`Missing created in ${rel}`);
    if (!data.updated) throw new Error(`Missing updated in ${rel}`);

    return {
      id: data.id,
      title: data.title,
      created: data.created,
      updated: data.updated,
      tags: Array.isArray(data.tags) ? data.tags : [],
      links: Array.isArray(data.links) ? data.links : [],
      path: rel,
      content: parsed.content.trim(),
      content_hash: this.sha256(raw)
    };
  }
/*
  upsertFromFile(filePath: string) {
    try {
      const note = this.parseNote(filePath);
      this.notes.set(note.id, note);
      console.log(`‚ú® Indexed: ${note.path}`);
      this.save();
    } catch (err: any) {
      console.error(`‚ùå Error parsing ${filePath}:`, err.message);
    }
  }*/
}

//
// --- MAIN WATCHER LOGIC ---
//
(async () => {
  const db = new JSONDatabase();

  console.log("üëÄ Watching notes folder:", NOTES_DIR);

  const watcher = chokidar.watch(`${NOTES_DIR}/**/*.md`, {
    ignoreInitial: false,
    persistent: true,
  });

  watcher
    .on("add", (file) => {
      console.log("\nüìÑ Added:", file);
      db.upsertFromFile(file);
    })
    .on("change", (file) => {
      console.log("\n‚úèÔ∏è Modified:", file);
      db.upsertFromFile(file);
    })
    .on("unlink", (file) => {
      console.log("\nüóë Deleted:", file);
      const rel = path.relative(NOTES_DIR, file);
      const removed = db.removeByPath(rel);
      if (removed) scheduleSave(db);
    });

})();


// scripts/_paths.ts
import path from "path";

export const ROOT_DIR = path.resolve(__dirname, "..");
export const NOTES_DIR = path.resolve(ROOT_DIR, "notes");
export const APP_DIR = path.resolve(ROOT_DIR, ".app");
export const DB_PATH = path.resolve(APP_DIR, "index.sqlite");


// scripts/frontmatter.ts
export function validateFrontmatter(data: any, ctx: string) {
	function ensure(field: string) {
		if (!data[field]) {
			throw new Error(`Missing '${field}' in frontmatter: ${ctx}`);
		}
	}

	ensure("id");
	ensure("title");
	ensure("created");
	ensure("updated");

	// ISO date strict
	const iso = /^\d{4}-\d{2}-\d{2}$/;
	if (!iso.test(data.created)) {
		throw new Error(`Invalid ISO date 'created' in ${ctx} (expected YYYY-MM-DD)`);
	}
	if (!iso.test(data.updated)) {
		throw new Error(`Invalid ISO date 'updated' in ${ctx} (expected YYYY-MM-DD)`);
	}

	// Optional fields normalization
	data.tags = Array.isArray(data.tags) ? data.tags.map(String) : [];
	data.links = Array.isArray(data.links) ? data.links.map(String) : [];
	data.status = data.status ?? "active";
}


// scripts/db.ts
// scripts/json-db.ts
import fs from 'fs';
import path from 'path';
import matter from 'gray-matter';
import crypto from 'crypto';
import { dirname } from 'node:path';
import { fileURLToPath } from 'node:url';
// Source - https://stackoverflow.com/a/50052194
// Posted by GOTO 0, modified by community. See post 'Timeline' for change history
// Retrieved 2026-02-12, License - CC BY-SA 4.0

const __dirname = dirname(fileURLToPath(import.meta.url));

const NOTES_DIR = path.resolve(__dirname, '../notes');
const INDEX_PATH = path.resolve(__dirname, '../notes-index.json');

type Note = {
  id: string;
  path: string;
  title: string;
  created: string;
  updated: string;
  tags: string[];
  links: string[];
  content: string;
  content_hash: string;
};

type TagStats = {
  tag: string;
  count: number;
};

type DatabaseStats = {
  totalNotes: number;
  totalTags: number;
  totalWords: number;
  topTags: TagStats[];
};

class JSONDatabase {
  private notes: Map<string, Note> = new Map();
  private tagsIndex: Map<string, Set<string>> = new Map();
  private contentIndex: Map<string, string> = new Map(); // For fast search

  load(): void {
    if (fs.existsSync(INDEX_PATH)) {
      try {
        const data = JSON.parse(fs.readFileSync(INDEX_PATH, 'utf8'));
        this.notes.clear();
        this.tagsIndex.clear();
        this.contentIndex.clear();

        data.forEach((note: Note) => {
          this.notes.set(note.id, note);
          
          // Index tags
          note.tags.forEach((tag: string) => {
            if (!this.tagsIndex.has(tag)) {
              this.tagsIndex.set(tag, new Set());
            }
            const tagSet = this.tagsIndex.get(tag);
            if (tagSet) {
              tagSet.add(note.id);
            }
          });
          
          // Index content for search
          this.contentIndex.set(note.id, note.content.toLowerCase());
        });

        console.log(`Loaded ${this.notes.size} notes from index`);
      } catch (error) {
        console.error('Failed to load index:', error);
      }
    }
  }

  save(): void {
    const notesArray = Array.from(this.notes.values());
    fs.writeFileSync(INDEX_PATH, JSON.stringify(notesArray, null, 2));
    console.log(`‚úÖ Saved ${notesArray.length} notes to ${INDEX_PATH}`);
  }

  walk(dir: string): string[] {
    if (!fs.existsSync(dir)) {
      console.warn(`Directory does not exist: ${dir}`);
      return [];
    }
    
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    return entries.flatMap((entry: fs.Dirent) => {
      const fullPath = path.join(dir, entry.name);
      if (entry.isDirectory()) return this.walk(fullPath);
      if (entry.isFile() && entry.name.endsWith('.md')) return [fullPath];
      return [];
    });
  }

  sha256(text: string): string {
    return crypto.createHash('sha256').update(text).digest('hex');
  }
private lastHashByPath: Map<string, string> = new Map();

// salva immediatamente l'indice? -> gestiremo fuori (watcher) con debounce
save(): void {
  const notesArray = Array.from(this.notes.values());
  fs.writeFileSync(INDEX_PATH, JSON.stringify(notesArray, null, 2));
  console.log(`‚úÖ Saved ${notesArray.length} notes to ${INDEX_PATH}`);
}

// nuovo: parseAndMaybeUpsert restituisce true se ha cambiato qualcosa
parseAndMaybeUpsert(filePath: string): boolean {
  const raw = fs.readFileSync(filePath, 'utf8');
  const parsed = matter(raw);
  const relPath = path.relative(NOTES_DIR, filePath);
  const data = parsed.data as any;

  // (opzionale) valida frontmatter se vuoi enforcement stretto
  // validateFrontmatter(data, relPath);

  const today = new Date().toISOString().split("T")[0];
  const contentHash = this.sha256(raw);
  const lastHash = this.lastHashByPath.get(relPath);
  if (lastHash === contentHash) {
    // contenuto invariato: nessun update necessario
    return false;
  }

  // costruisci l'oggetto Note con fallback sicuri
  const note: Note = {
    id: (data.id ?? path.basename(filePath, ".md")).toString(),
    title: (data.title ?? "Untitled").toString(),
    created: (data.created ?? today).toString(),
    updated: (data.updated ?? today).toString(),
    tags: Array.isArray(data.tags) ? data.tags.map(String) : [],
    links: Array.isArray(data.links) ? data.links.map(String) : [],
    path: relPath,
    content: (parsed.content ?? "").trim(),
    content_hash: contentHash,
  };

  this.notes.set(note.id, note);
  this.lastHashByPath.set(relPath, contentHash);
  console.log(`‚ú® Indexed: ${note.path}`);
  return true;
}

// utile quando rimuovi un file: elimina via path
removeByPath(relPath: string): boolean {
  let removed = false;
  for (const [id, note] of this.notes.entries()) {
    if (note.path === relPath) {
      this.notes.delete(id);
      this.lastHashByPath.delete(relPath);
      console.log(`üóë Removed: ${relPath}`);
      removed = true;
      break;
    }
  }
  return removed;
}
  parseNote(filePath: string): Note {
    const raw = fs.readFileSync(filePath, 'utf8');
    const parsed = matter(raw);
    const relPath = path.relative(NOTES_DIR, filePath);
    
    const data = parsed.data as any;
    const today = new Date().toISOString().split("T")[0];
    
    return {
      id: (data.id ?? path.basename(filePath, '.md')).toString(),
      path: relPath,
      title: (data.title ?? 'Untitled').toString(),
      created: (data.created ?? today).toString(),
      updated: (data.updated ?? today).toString(),
      tags: Array.isArray(data.tags) ? data.tags.map(String) : [],
      links: Array.isArray(data.links) ? data.links.map(String) : [],
      content: (parsed.content ?? '').trim(),
      content_hash: this.sha256(raw)
    };
  }

  indexNotes(): Note[] {
    console.log(`üìÅ Scanning ${NOTES_DIR} for markdown files...`);
    
    // Check if notes directory exists
    if (!fs.existsSync(NOTES_DIR)) {
      console.log(`Creating notes directory at ${NOTES_DIR}...`);
      fs.mkdirSync(NOTES_DIR, { recursive: true });
      
      // Create a sample note
      const sampleNote = `---
id: sample-note
title: Welcome to Your Note System
created: 2024-01-01
updated: 2024-01-01
tags: [welcome, getting-started]
links: []
---

# Welcome!

This is your first note. You can:

1. Add more notes in the \`notes/\` directory
2. Use frontmatter for metadata
3. Search notes with \`pnpm search "query"\`

## Frontmatter Example

\`\`\`yaml
---
id: unique-id
title: Note Title
created: YYYY-MM-DD
updated: YYYY-MM-DD
tags: [tag1, tag2]
links: [other-note-id]
---
\`\`\``;
      
      fs.writeFileSync(path.join(NOTES_DIR, 'welcome.md'), sampleNote);
    }
    
    const files = this.walk(NOTES_DIR);
    console.log(`üìÑ Found ${files.length} markdown files`);
    
    if (files.length === 0) {
      console.log('No markdown files found. A sample note has been created.');
      files.push(path.join(NOTES_DIR, 'welcome.md'));
    }
    
    const notes: Note[] = [];
    const seenIds = new Set<string>();
    
    for (const file of files) {
      try {
        const note = this.parseNote(file);
        
        if (seenIds.has(note.id)) {
          console.warn(`‚ö†Ô∏è  Duplicate ID: "${note.id}" in ${note.path}`);
          // Make ID unique
          note.id = `${note.id}-${Date.now()}`;
        }
        seenIds.add(note.id);
        
        notes.push(note);
        console.log(`‚úì ${note.path}`);
      } catch (error: any) {
        console.error(`‚úó Error processing ${file}:`, error.message);
      }
    }
    
    // Update database
    this.notes.clear();
    this.tagsIndex.clear();
    this.contentIndex.clear();
    
    notes.forEach((note: Note) => {
      this.notes.set(note.id, note);
      
      // Index tags
      note.tags.forEach((tag: string) => {
        if (!this.tagsIndex.has(tag)) {
          this.tagsIndex.set(tag, new Set());
        }
        const tagSet = this.tagsIndex.get(tag);
        if (tagSet) {
          tagSet.add(note.id);
        }
      });
      
      // Index content for search
      this.contentIndex.set(note.id, note.content.toLowerCase());
    });
    
    this.save();
    
    // Sort by updated date (newest first)
    notes.sort((a: Note, b: Note) => b.updated.localeCompare(a.updated));
    
    return notes;
  }

  search(query: string): Note[] {
    const lowerQuery = query.toLowerCase();
    
    return Array.from(this.notes.values())
      .filter((note: Note) => {
        return note.title.toLowerCase().includes(lowerQuery) ||
               note.content.toLowerCase().includes(lowerQuery) ||
               note.tags.some((tag: string) => tag.toLowerCase().includes(lowerQuery)) ||
               note.id.toLowerCase().includes(lowerQuery);
      })
      .sort((a: Note, b: Note) => b.updated.localeCompare(a.updated));
  }

  getStats(): DatabaseStats {
    const notes = Array.from(this.notes.values());
    const tags = new Map<string, number>();
    
    notes.forEach((note: Note) => {
      note.tags.forEach((tag: string) => {
        tags.set(tag, (tags.get(tag) || 0) + 1);
      });
    });
    
    const topTags: TagStats[] = Array.from(tags.entries())
      .sort((a: [string, number], b: [string, number]) => b[1] - a[1])
      .slice(0, 10)
      .map(([tag, count]: [string, number]) => ({ tag, count }));
    
    return {
      totalNotes: notes.length,
      totalTags: tags.size,
      totalWords: notes.reduce((sum: number, note: Note) => sum + note.content.split(/\s+/).length, 0),
      topTags
    };
  }
}

// Create and export database instance
const db = new JSONDatabase();
db.load();

// Command line interface
// --- CLI ENTRYPOINT (ES MODULE COMPATIBLE) ---

const command = process.argv[2];

if (command === "index") {
  console.log("üîç Indexing notes...");
  const notes = db.indexNotes();
  const stats = db.getStats();
  console.log("\nüìä Summary:");
  console.log(` Total notes: ${stats.totalNotes}`);
  console.log(` Total tags: ${stats.totalTags}`);
  console.log(` Total words: ${stats.totalWords}`);
  if (stats.topTags.length > 0) {
    console.log(` Top tags: ${stats.topTags.map(t => `${t.tag}(${t.count})`).join(", ")}`);
  }
} else if (command === "search") {
  const query = process.argv.slice(3).join(" ").trim();
  if (!query) {
    console.error('Usage: pnpm search-db "query"');
    process.exit(1);
  }
  console.log(`üîç Searching for "${query}"...`);
  const results = db.search(query);
  if (results.length === 0) console.log("No results found.");
  else {
    console.log(`\nFound ${results.length} result(s):\n`);
    for (const note of results) {
      console.log(`- [${note.id}] ${note.title}`);
      console.log(`  Path: ${note.path}`);
      console.log(`  Updated: ${note.updated}`);
      if (note.tags.length > 0) console.log(`  Tags: ${note.tags.join(", ")}`);
      const excerpt = note.content.substring(0, 150).replace(/\n/g, " ");
      console.log(`  Excerpt: ${excerpt}${note.content.length > 150 ? "..." : ""}\n`);
    }
  }
} else if (command === "list") {
  const allNotes = Array.from(db["notes"].values()).sort((a, b) =>
    b.updated.localeCompare(a.updated)
  );
  console.log(`Total notes: ${allNotes.length}\n`);
  for (const note of allNotes) {
    console.log(`- [${note.id}] ${note.title}`);
    console.log(`  ${note.path} (updated: ${note.updated})`);
    if (note.tags.length > 0) console.log(`  Tags: ${note.tags.join(", ")}`);
    console.log();
  }
} else if (command === "stats") {
  const stats = db.getStats();
  console.log("üìà Statistics:");
  console.log(` Total notes: ${stats.totalNotes}`);
  console.log(` Total tags: ${stats.totalTags}`);
  console.log(` Total words: ${stats.totalWords}`);
  if (stats.topTags.length > 0) {
    console.log("\n Top tags:");
    for (const tag of stats.topTags) {
      console.log(`  ${tag.tag}: ${tag.count}`);
    }
  }
} else {
  console.log("üìù Note Management System (JSON)");
  console.log("==============================\n");
  console.log("Usage:");
  console.log(" pnpm index-db   - Index all notes");
  console.log(" pnpm search-db  - Search notes");
  console.log(" pnpm list-db    - List all notes");
  console.log(" pnpm stats-db   - Show statistics\n");
}



// scripts/search.ts
// scripts/search.ts
import fs from "fs";
import path from "path";

const query = process.argv.slice(2).join(" ").trim();
if (!query) {
  console.error('Usage: pnpm search-db "your query"');
  process.exit(1);
}

const INDEX_PATH = path.resolve(__dirname, "../notes-index.json");
const data = JSON.parse(fs.readFileSync(INDEX_PATH, "utf8")) as Array<{
  id:string; title:string; path:string; content:string; updated:string; tags:string[];
}>;

const q = query.toLowerCase();
const results = data.filter(n =>
  n.title.toLowerCase().includes(q) ||
  n.content.toLowerCase().includes(q) ||
  n.tags.some(t => t.toLowerCase().includes(q)) ||
  n.id.toLowerCase().includes(q)
).sort((a,b) => b.updated.localeCompare(a.updated));

if (results.length === 0) console.log("No results.");
else {
  console.log(`Found ${results.length} results:`);
  for (const r of results) {
    const ex = (r.content ?? "").slice(0, 150).replace(/\n/g, " ");
    console.log(`\n - [${r.id}] ${r.title} (${r.path})`);
    if (ex) console.log(`   ${ex}${r.content.length>150?"...":""}`);
  }
}


// scripts/index-notes.ts
import * as fs from "fs";
import * as path from "path";
const matter = require("gray-matter");

const NOTES_DIR = path.resolve(__dirname, "../notes");

type NoteIndex = {
	id: string;
	title: string;
	path: string;
	created: string;
	updated: string;
};

function walk(dir: string): string[] {
	const entries = fs.readdirSync(dir, { withFileTypes: true});
	return entries.flatMap((entry) => {
		const fullPath = path.join(dir, entry.name);
		if (entry.isDirectory()) return walk(fullPath);
		if (entry.isFile() && entry.name.endsWith(".md")) return [fullPath];
		return [];
	});
}

function indexNotes(): NoteIndex[] {
	const files = walk(NOTES_DIR);
	const seenIds = new Set<string>();
	const index: NoteIndex[] = [];

	for (const file of files) {
		const raw = fs.readFileSync(file, "utf8");
		const parsed = matter(raw);
		const data = parsed.data as Partial<NoteIndex>;
		
		// Minimal validations
		if (!data.id) {
			throw new Error(`Duplicate id '${file}`);
		}
		if (seenIds.has(data.id)) {
			throw new Error(`Missing required fields in ${file}`);
		}
		if (!data.title || !data.created || !data.updated) {
			throw new Error(`Missing required fields in ${file}`);
		}

		seenIds.add(data.id);

		index.push({
			id: data.id,
			title: data.title,
			created: data.created,
			updated: data.updated,
			path: path.relative(NOTES_DIR, file),
		});
	}

	return index;
}

// ---- run ----
try {
	const notes = indexNotes();
	console.log("Indexed notes:");
	for (const note of notes) {
		console.log(`- [${note.id}] ${note.title} (${note.path})`);
	}
	console.log(`\nTotal notes: ${notes.length}`);
} catch (err) {
	console.error("Indexing failed:");
	console.error(err);
	process.exit(1);
}


// package.json
{
  "name": "ercole",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "engines": { "node": ">=20.19.0" },
  "scripts": {
    "index-db": "ts-node scripts/db.ts index",
    "search-db": "ts-node scripts/db.ts search",
    "list-db": "ts-node scripts/db.ts list",
    "stats-db": "ts-node scripts/db.ts stats",
    "watch-db": "node --loader ts-node/esm scripts/watch.ts",
    "lint": "eslint .",
    "format": "prettier -w ."
  },
  "dependencies": {
    "chokidar": "^5.0.0",
    "gray-matter": "^4.0.3"
  },
  "devDependencies": {
    "@types/node": "^25.2.2",
    "ts-node": "^10.9.2",
    "typescript": "^5.9.3",
    "eslint": "^9",
    "prettier": "^3"	
  }
}


